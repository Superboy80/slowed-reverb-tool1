<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Slowed Reverb Tool</title>
<style>
  body { font-family: Arial, sans-serif; background:#121212; color:#fff; display:flex; flex-direction:column; align-items:center; padding:20px; }
  h1 { color:#f39c12; }
  input[type=file] { margin:10px 0; }
  .slider-container { margin:10px 0; width:300px; }
  .slider-container label { display:block; margin-bottom:5px; }
  .slider-container input { width:100%; }
  #playBtn, #stopBtn, #downloadBtn { margin:5px; padding:10px 15px; font-size:16px; cursor:pointer; }
  #uploadStatus { margin:10px 0; }
  #timeDisplay { margin-top:10px; }
  canvas { margin-top:20px; border:1px solid #fff; width:300px; height:80px; }
</style>
</head>
<body>
<h1>Slowed Reverb Tool</h1>

<input type="file" id="fileInput" accept="audio/*">
<div id="uploadStatus"></div>

<div class="slider-container">
  <label for="volumeSlider">Volume: <span id="volumeValue">100%</span></label>
  <input type="range" id="volumeSlider" min="0" max="100" value="100">
</div>

<div class="slider-container">
  <label for="speedSlider">Speed: <span id="speedValue">1.0x</span></label>
  <input type="range" id="speedSlider" min="0.5" max="2" step="0.01" value="1">
</div>

<div class="slider-container">
  <label for="reverbSlider">Reverb: <span id="reverbValue">0%</span></label>
  <input type="range" id="reverbSlider" min="0" max="100" value="0">
</div>

<button id="playBtn">Play</button>
<button id="stopBtn">Stop</button>
<button id="downloadBtn">Download</button>

<div id="timeDisplay">0:00 / 0:00</div>
<canvas id="visualizer"></canvas>

<script>
let audioCtx, source, audioBuffer, gainNode, convolver, reverbBuffer;
let isPlaying = false;
let startTime = 0;
let pauseOffset = 0;

// Visualizer
const canvas = document.getElementById("visualizer");
const ctx = canvas.getContext("2d");

// Load reverb impulse (simple one)
function createReverbBuffer(ctx, amount) {
  const length = ctx.sampleRate * 3;
  const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
  for (let channel = 0; channel < 2; channel++) {
    const channelData = buffer.getChannelData(channel);
    for (let i = 0; i < length; i++) {
      channelData[i] = (Math.random() * 2 - 1) * amount;
    }
  }
  return buffer;
}

document.getElementById("fileInput").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  const status = document.getElementById("uploadStatus");
  if (!file) return;
  status.textContent = "⏳ Uploading / Decoding audio...";
  try {
    const arrayBuffer = await file.arrayBuffer();
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
    status.textContent = "✅ Audio loaded! Ready to play.";
    pauseOffset = 0;
    updateTimeDisplay();
  } catch(err) {
    status.textContent = "❌ Error loading audio!";
    console.error(err);
  }
});

function setupAudioNodes() {
  gainNode = audioCtx.createGain();
  convolver = audioCtx.createConvolver();
  reverbBuffer = createReverbBuffer(audioCtx, reverbSlider.value / 100);
  convolver.buffer = reverbBuffer;

  source = audioCtx.createBufferSource();
  source.buffer = audioBuffer;
  source.playbackRate.value = parseFloat(speedSlider.value);
  source.connect(convolver);
  convolver.connect(gainNode);
  gainNode.connect(audioCtx.destination);
}

function playAudio() {
  if (!audioBuffer) return;
  if (isPlaying) return;
  setupAudioNodes();
  startTime = audioCtx.currentTime - pauseOffset;
  source.start(0, pauseOffset);
  isPlaying = true;
  drawVisualizer();
}

function stopAudio() {
  if (!isPlaying) return;
  source.stop();
  pauseOffset = audioCtx.currentTime - startTime;
  isPlaying = false;
}

document.getElementById("playBtn").addEventListener("click", () => playAudio());
document.getElementById("stopBtn").addEventListener("click", () => stopAudio());

const volumeSlider = document.getElementById("volumeSlider");
const volumeValue = document.getElementById("volumeValue");
volumeSlider.addEventListener("input", () => {
  if (gainNode) gainNode.gain.value = volumeSlider.value / 100;
  volumeValue.textContent = volumeSlider.value + "%";
});

const speedSlider = document.getElementById("speedSlider");
const speedValue = document.getElementById("speedValue");
speedSlider.addEventListener("input", () => {
  speedValue.textContent = parseFloat(speedSlider.value).toFixed(2) + "x";
  if (source && isPlaying) {
    stopAudio();
    playAudio();
  }
});

const reverbSlider = document.getElementById("reverbSlider");
const reverbValue = document.getElementById("reverbValue");
reverbSlider.addEventListener("input", () => {
  reverbValue.textContent = reverbSlider.value + "%";
  if (convolver) {
    reverbBuffer = createReverbBuffer(audioCtx, reverbSlider.value / 100);
    convolver.buffer = reverbBuffer;
  }
});

function updateTimeDisplay() {
  if (!audioBuffer) {
    document.getElementById("timeDisplay").textContent = "0:00 / 0:00";
    return;
  }
  const current = isPlaying ? audioCtx.currentTime - startTime : pauseOffset;
  const total = audioBuffer.duration;
  const formatTime = (t) => Math.floor(t/60) + ":" + String(Math.floor(t%60)).padStart(2,"0");
  document.getElementById("timeDisplay").textContent = formatTime(current) + " / " + formatTime(total);
  requestAnimationFrame(updateTimeDisplay);
}

function drawVisualizer() {
  if (!audioCtx) return;
  const analyser = audioCtx.createAnalyser();
  convolver.connect(analyser);
  analyser.fftSize = 256;
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Uint8Array(bufferLength);

  function draw() {
    if (!isPlaying) return;
    requestAnimationFrame(draw);
    analyser.getByteFrequencyData(dataArray);
    ctx.fillStyle = "#121212";
    ctx.fillRect(0,0,canvas.width,canvas.height);
    const barWidth = canvas.width / bufferLength;
    dataArray.forEach((value,i)=>{
      ctx.fillStyle = "#f39c12";
      const barHeight = value/2;
      ctx.fillRect(i*barWidth,canvas.height-barHeight,barWidth,barHeight);
    });
  }
  draw();
}

// Download
document.getElementById("downloadBtn").addEventListener("click", async () => {
  if (!audioBuffer) return;
  const offlineCtx = new OfflineAudioContext(audioBuffer.numberOfChannels, audioBuffer.length, audioBuffer.sampleRate);
  const offlineSource = offlineCtx.createBufferSource();
  offlineSource.buffer = audioBuffer;

  const offlineGain = offlineCtx.createGain();
  offlineGain.gain.value = volumeSlider.value / 100;

  const offlineConvolver = offlineCtx.createConvolver();
  offlineConvolver.buffer = createReverbBuffer(offlineCtx, reverbSlider.value / 100);

  offlineSource.connect(offlineConvolver);
  offlineConvolver.connect(offlineGain);
  offlineGain.connect(offlineCtx.destination);

  offlineSource.start(0);
  const renderedBuffer = await offlineCtx.startRendering();

  const wavBuffer = audioBufferToWav(renderedBuffer);
  const blob = new Blob([new DataView(wavBuffer)], {type:"audio/wav"});
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "processed_audio.wav";
  a.click();
});

function audioBufferToWav(buffer) {
  const numOfChan = buffer.numberOfChannels,
    length = buffer.length * numOfChan * 2 + 44,
    bufferArray = new ArrayBuffer(length),
    view = new DataView(bufferArray);
  let offset = 0, pos = 0;

  function writeString(str) { for(let i=0;i<str.length;i++){ view.setUint8(pos++, str.charCodeAt(i)); } }

  writeString('RIFF'); view.setUint32(pos, length-8, true); pos+=4;
  writeString('WAVE'); writeString('fmt '); view.setUint32(pos,16,true); pos+=4;
  view.setUint16(pos,1,true); pos+=2; view.setUint16(pos,numOfChan,true); pos+=2;
  view.setUint32(pos,buffer.sampleRate,true); pos+=4;
  view.setUint32(pos,buffer.sampleRate*numOfChan*2,true); pos+=4;
  view.setUint16(pos,numOfChan*2,true); pos+=2; view.setUint16(pos,16,true); pos+=2;
  writeString('data'); view.setUint32(pos,length-44,true); pos+=4;

  const interleaved = interleave(buffer);
  while(offset<interleaved.length){ view.setInt16(pos,interleaved[offset]*0x7fff,true); pos+=2; offset++; }
  return bufferArray;
}

function interleave(buffer) {
  const numOfChan = buffer.numberOfChannels;
  const length = buffer.length;
  const result = new Float32Array(length*numOfChan);
  let index=0;
  for(let i=0;i<length;i++){
    for(let ch=0;ch<numOfChan;ch++){
      result[index++] = buffer.getChannelData(ch)[i];
    }
  }
  return result;
}
</script>
</body>
</html>
