document.addEventListener('DOMContentLoaded', function() {
    const audioFileInput = document.getElementById('audioFile');
    const processBtn = document.getElementById('processBtn');
    const progress = document.getElementById('progress');
    const progressBar = progress.querySelector('.progress-bar');
    const preview = document.getElementById('preview');
    const downloadLink = document.getElementById('downloadLink');
    const errorMsg = document.getElementById('errorMsg');
    const slowSpeed = document.getElementById('slowSpeed');
    const reverbTime = document.getElementById('reverbTime');
    const speedValue = document.getElementById('speedValue');
    const reverbValue = document.getElementById('reverbValue');

    // Update sliders display
    slowSpeed.addEventListener('input', () => speedValue.textContent = slowSpeed.value + 'x');
    reverbTime.addEventListener('input', () => reverbValue.textContent = reverbTime.value + 's');

    // File upload
    audioFileInput.addEventListener('change', function(e) {
        const file = e.target.files[0];
        if (file && file.size > 100 * 1024 * 1024) {
            showError('File too large! Max 100MB.');
            return;
        }
        if (file) {
            processBtn.disabled = false;
            preview.src = URL.createObjectURL(file); // Preview original
            preview.style.display = 'block';
        }
    });

    // Process button
    processBtn.addEventListener('click', async function() {
        const file = audioFileInput.files[0];
        if (!file) {
            showError('Please upload a file first!');
            return;
        }

        showProgress(0);
        try {
            const audioBuffer = await loadAudio(file);
            const processedBuffer = await applyEffects(audioBuffer, parseFloat(slowSpeed.value), parseFloat(reverbTime.value));
            const processedBlob = await bufferToWave(processedBuffer, file.sampleRate || 44100);
            const url = URL.createObjectURL(processedBlob);
            
            downloadLink.href = url;
            downloadLink.download = `slowed-reverb_${file.name}`;
            downloadLink.style.display = 'block';
            preview.src = url; // Preview processed
            hideError();
        } catch (err) {
            showError('Error processing audio: ' + err.message);
        }
        hideProgress();
    });

    // Helper functions
    async function loadAudio(file) {
        const arrayBuffer = await file.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        showProgress(25);
        return await audioContext.decodeAudioData(arrayBuffer);
    }

    async function applyEffects(buffer, speed, reverbTime) {
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        const source = audioContext.createBufferSource();
        source.buffer = buffer;

        // Slowed effect (change playback rate)
        const slowedBuffer = audioContext.createBuffer(buffer.numberOfChannels, buffer.length / speed, buffer.sampleRate * speed);
        for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
            const inputData = buffer.getChannelData(channel);
            const outputData = slowedBuffer.getChannelData(channel);
            for (let i = 0; i < slowedBuffer.length; i++) {
                outputData[i] = inputData[Math.floor(i * speed)] || 0;
            }
        }
        source.buffer = slowedBuffer;

        // Reverb effect (simple convolver)
        const reverb = audioContext.createConvolver();
        const reverbBuffer = audioContext.createBuffer(1, audioContext.sampleRate * reverbTime, audioContext.sampleRate);
        const reverbData = reverbBuffer.getChannelData(0);
        // Simple impulse response for reverb (you can make it more complex)
        for (let i = 0; i < reverbData.length; i++) {
            reverbData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbData.length, 2);
        }
        reverb.buffer = reverbBuffer;

        const gain = audioContext.createGain();
        gain.gain.value = 0.7; // Mix to avoid clipping

        source.connect(reverb);
        reverb.connect(gain);
        gain.connect(audioContext.destination);

        // Render to offline buffer for download
        const offlineContext = new OfflineAudioContext(buffer.numberOfChannels, slowedBuffer.length, slowedBuffer.sampleRate);
        const offlineSource = offlineContext.createBufferSource();
        offlineSource.buffer = slowedBuffer;
        offlineSource.connect(reverb);
        reverb.buffer = reverbBuffer; // Reuse
        reverb.connect(offlineContext.destination);
        showProgress(50);
        return await offlineSource.start(0);
        showProgress(75);
        return await offlineContext.startRendering();
    }

    function bufferToWave(buffer, sampleRate) {
        const numChannels = buffer.numberOfChannels;
        const length = buffer.length * numChannels * 2 + 44;
        const arrayBuffer = new ArrayBuffer(length);
        const view = new DataView(arrayBuffer);
        const writeString = (offset, string) => {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        };
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + buffer.length * numChannels * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * 2, true);
        view.setUint16(32, numChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, buffer.length * numChannels * 2, true);

        // Write samples
        let offset = 44;
        for (let i = 0; i < buffer.length; i++) {
            for (let channel = 0; channel < numChannels; channel++) {
                const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                view.setInt16(offset, sample * 0x7FFF, true);
                offset += 2;
            }
        }
        showProgress(100);
        return new Blob([arrayBuffer], { type: 'audio/wav' });
    }

    function showProgress(percent) {
        progress.style.display = 'block';
        progressBar.style.width = percent + '%';
        progressBar.textContent = 'Processing... ' + percent + '%';
    }

    function hideProgress() {
        progress.style.display = 'none';
    }

    function showError(msg) {
        errorMsg.textContent = msg;
        errorMsg.style.display = 'block';
        processBtn.disabled = true;
    }

    function hideError() {
        errorMsg.style.display = 'none';
    }
});
